# New Feature: Setup CI with GitHub actions

Currently a Linux development PC is the only machine executing the tests.
A CI system would provide a neutral source for test results and enables to provide automated feedback to pull request authors.

Further reading on Bazel and GitHub actions: https://dev.to/davidb31/experimentations-on-bazel-github-action-5639

# Evaluation: Dependency utilization

Is the feature to analyze the dependency utilization indeed useful?

It is not part of the core DWYU concept to make sure only header from direct dependencies are used and no superfluous dependencies exist.
While the implementation of the feature is not complex it is still code which has to be tested, documented and maintained.
On top, the feature is not reliable when virtual includes are involved.
Furthermore, most likely an extension will be required to allow users to specify an allow list of dependencies where low utilizations are accepted for whatever reason.

Then again, having small targets allows building slim and efficient dependency trees and this feature can help with that.
Moving this into an own project seems wasteful, since the implementation would be mostly identical to DWYU.

Current ideas:
* Remove it, if user feedback for this is not positive. It is not part to invest much here, since it is not a core DWYU feature.
* If user feedback is positive, move it into an own tool/aspect but reuse the DWYU implementation.

# New Feature: Automatic fixes

A separate tool could read all the report files generated by DWYU and then invoke [buildozer](https://github.com/bazelbuild/buildtools/blob/master/buildozer/README.md) to apply the fixes to the workspace.
This would allow automatically removing unused dependencies and moving public dependencies to `implementation_deps`.

# Improvement: Support more include patterns

The [known limitations](#Known-limitations) are caused by the complexity of all possible ways to include a header in C++.
The complexity is caused mainly by the preprocessor which allows dynamically adding include statements through macros and to enable/disable includes based on defines.

We could reimplement the preprocessor logic inside DWYU to support more complex include patterns.
The benefit would be that DYWU remains self-contained without external dependencies.
However, this would also be reinventing the wheel.
The C preprocessor is an old problem which has been solved many times until now.
Trying to implement and test a C preprocessor solely for the sake of prevent third party dependencies is wasteful.
The world does not need yet another C Preprocessor.

No design how to proceed has been made up yet.

The following tools could be part of the solution if we want to keep Python as implementation language:
* https://pypi.org/project/pcpp/
* https://github.com/paulross/cpip
* https://github.com/eliben/pycparser
* https://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang

We could also move the implementation to C++.
The LLVM toolchain is a quite powerful toolset and allows interaction with the preprocessor.
See for example https://clang.llvm.org/doxygen/classclang_1_1Preprocessor.html#details.
LLVM is however not a lightweight dependency and having to compile DWYU will reduce its portability.

Yet another possibility is telling the compiler to generate a `.d` file, which lists the includes required for a given source file.
This provides an easy to parse output listing all include statements which are required after resolving macros and defines.
However, a first test shows all transitive headers are resolved.
This is a problem, since we need to know the include statements for the file under inspection, but not more.
If all transitive includes are listed as well, we cannot compare this list to the direct dependencies.
It is not yet known if this behavior can be modified.

# New Feature: Use bazelmod for third_party

Bazel 5.0.0 introduced a new approach to manage external dependencies.
See [bazelmod](https://docs.bazel.build/versions/5.0.0/bzlmod.html).

# Improvement: Utilize GitHub projects

Utilize GitHub issues and project boards to organized the roadmap TODOs.
